\documentclass[fleqn,reqno]{amsart}
\usepackage{../lib/radoslav-macro}
\usepackage{../lib/radoslav-more}
\usepackage{times}
\usepackage{natbib}

\newcounter{chapter}
\setcounter{chapter}{6}
\numberwithin{first}{chapter}

\begin{document}
%% STRIP END



\begin{paragraf*}
This chapter is devoted to the computational aspects of our results.
Section~\ref{sec:algorithms} describes two algorithms for implicitization.
The first one is simple and robust, and is used for studying the matrices $N$
when Gr\"obner basis calculations can be carried out efficiently.
The second one is more involved and is used when direct computations are unfeasible.
In those cases its lead is significant.
Section~\ref{sec:long-examples} provides details about the algorithms
and support to the claim in the form of a few worked examples.
\end{paragraf*}

\begin{paragraf*}
Both, as means to illustrate that our algorithms are effective in the sense of
computational algebraic geometry,
and as a setup for the examples to follow,
Section~\ref{sec:implementation} includes Macaulay2 code implementing
the algorithms of Section~\ref{sec:algorithms}.
\end{paragraf*}

\begin{paragraf*}
The complete code is available at
\begin{center}
	\url{http://www.math.cornell.edu/~rzlatev/phd-thesis}
\end{center}
\end{paragraf*}

\begin{paragraf*}
We continue to follow the notation of Chapter \ref{ch:preliminaries}
and the setup of Chapter \ref{ch:main-results}.
However, to avoid distraction, we assume throughout the chapter that $\phi$ is generically 1-1.
\end{paragraf*}



\section{The Algorithms}
\label{sec:algorithms}

\begin{paragraf*}
At first glance, an algorithm for finding the implicit equation is contained in the proof
of the our main theorem, Theorem \ref{thm:gcd-minors}.
In its simplest form, it becomes
\end{paragraf*}

% \begin{absolutelynopagebreak}
\begin{algorithm} {\sc Naive Algorithm\bf.}
\label{algo:naive}
\begin{algorithmic}
  \State {\bf input:} the ideal $J$ and a degree $\d$ on $S$
  \State {\bf output:} the matrix $N$ and the implicit equation $P$
  \State Set $r=\dim_\CC(S_{\mathbf d})$
  \State Compute an $R$-generating set $\{h_l:l\}$ for the Rees ideal $I$
  \State Compute a $T$-generating set $\{g_k:k\}$ for $I_{\d,\bullet}$ from the $h_l$
  	using Lemma \ref{lemma:push-gens}
  \State Set $N$ to be the coefficient matrix of the $g_k$ with respect to $\mt{basis}(S_\d)$
  \State Compute $P=\gcd(\mt{minors}(r,N))$
\end{algorithmic}
\end{algorithm}
% \end{absolutelynopagebreak}

\begin{paragraf}
\label{par:flaws}
The conciseness and robustness of Algorithm \ref{algo:naive} made it our preferred tool
for testing the theory.
In fact, all concrete calculations presented so far,
including all examples of Chapter \ref{ch:examples},
were carried out using this algorithm.

At the same time, its simplicity allows us to spot some of its drawbacks.
We discuss four major ones.
\begin{enumerate}
\item
\label{itm:flaws:GB}
Computing an $R$-generating set for the Rees ideal is at least as hard as
computing the implicit equation itself --- we have $I_{0,\bullet}=P$.
This follows from Proposition~\ref{prop:deg-GB} and shows up in Example~\ref{ex314}.

\item
\label{itm:flaws:many-minors}
While computing the $\gcd$ of two polynomials is fast,
on the last line we compute all minors,
and their number can be very large.
This happens even for reasonably small examples.
For instance, the smallest nonzero matrix $N$ for $\d=(2,2,1)$ in Example~\ref{ex603}
is of size $18\times50$.
The number of maximal minors is
\[
	\binom{50}{18}=18'053'528'883'775
\]
so even if it took the unrealistic $0.001$ seconds to compute each minor,
a single machine would require 572 years to compute them all.

\item
\label{itm:flaws:large-det}
Continuing with Example~\ref{ex603},
we note that each maximal minor is a determinant of an $18\times18$-matrix
of quartic forms in 5 variables.
Computing large determinants symbolically is time-consuming.
Indeed, we did not manage to compute any nonzero minor.

Example~\ref{ex602} involves a somewhat similar calculation ---
the determinant of a $12\times12$-matrix of quadratic forms in 5 variables
took about an hour to compute.
Scaling up, we can speculate that our $18\times18$ determinant would take somewhere
in the order of
\[
	13\times14\times15\times16\times17\times18=13'366'080
\]
hours.
That is about $1525$ years.

\item
\label{itm:flaws:large-poly}
Finally, suppose we have found the polynomial in question --- by whatever means.
It is a form of degree $48$ in 5 variables, and very likely dense in the monomials of that degree.
This suggests that the polynomial will be represented by
\[
	\binom{53}{5}=2'869'685
\]
coefficients.
\end{enumerate}
\end{paragraf}

\begin{paragraf*}
Regrettably,
\itmref{itm:flaws:large-det}{par:flaws} would be an issue for any algorithm
relying on computing determinants of representation matrices,
while \itmref{itm:flaws:large-poly}{par:flaws}
would be an issue for any implicitization algorithm whatsoever.
Rather than seeing these as obstacles,
we point them out as an argument {\em for} the idea of using
representation matrices in place of the implicit equation altogether.
We explore this theme further in the examples of Section~\ref{sec:long-examples}.
\end{paragraf*}

\begin{paragraf}
\label{par:proposed}
Fix a degree $\d$ as before and recall that
\[
	N=(~N_1~|~\cdots~|~N_\delta~)
\]

Consider the following.
\begin{enumerate}
\item
\label{itm:N'}
Instead of computing the whole matrix $N$, one can compute the $N_i$'s separately,
keeping track of a partial representation matrix $N'$.
\item
\label{itm:gcd}
Instead of computing all the minors, one only needs to compute sufficiently many to determine
the $\gcd$ correctly.
\end{enumerate}
\end{paragraf}

\begin{paragraf*}
These two simple observations produce an immense speed up on average.
The advantage of \itmref{itm:N'}{par:proposed} over computing an $R$-generating set for the
Rees ideal is that it uses only linear algebraic routines.
The advantage of computing only a sufficiently many, rather than all, of the minors is clear.
\end{paragraf*}

\begin{paragraf}
Let
\[
	N'=N'_i=(~N_1~|~\cdots~|~N_i~)
\]
be the partial matrix of syzygies up to degree $i$.
If $N'$ satisfies the condition
\begin{align}
	\label{C:matrix}
	\tag{C1}
	\deg(\gcd(\minors(r,N')))=\deg(P)
\end{align}
then $\gcd(\minors(r,N'))=P$.

This is true for any collection of matrices of syzygies $M_k$, as in \eqref{lemma:detM-P}.
Indeed, $P(\mathbf x)$ divides each $\det(M_k)$, so $P(x)$ divides the $\gcd$,
but both have the same degree by assumption.

In particular, this shows that if $\deg(\det(M))<\deg(P)$, then $M$ must be singular.
\end{paragraf}

\begin{paragraf}
Let $M_1,M_2$ be matrices of syzygies, as in \eqref{lemma:detM-P},
and let $Y_1,Y_2$ be the hypersurfaces in $\PP^n$ they define.
Let $L$ be a general line in $\PP^n$.
If $M_1,M_2$ satisfy the condition
\begin{align}
	\label{C:minors}
	\tag{C2}
	L\cap Y_1\cap Y_2\se Y
\end{align}
then $\gcd(\det(M_1),\det(M_2))=P$.

This condition can be used for testing \itmref{itm:gcd}{par:proposed}.
The claim follows from the generality of $L$ and because
\[
	Y_1\cap Y_2=V(\gcd(\det(M_1),\det(M_2)))
\]

Indeed, if the $\gcd$ is a proper multiple of $P$, then the intersection of
$Y_1$ and $Y_2$ contains another hypersurface, whose intersection with the general $L$
is not going to be on $Y$.
\end{paragraf}

\begin{paragraf*}
Summarizing the discussion so far, we propose
\end{paragraf*}

\begin{algorithm}{\sc Proposed Algorithm}{\bf.}
\label{algo:proposed}
\begin{algorithmic}
\State{{\bf input:} $J$, $\d$, $p$}
\State{{\bf output:} a list of matrices $M_k$ such that $\gcd(\{M_k:k\})=P$}
\State{Set $r=h^0(S_\mathbf d)$}
\State{Set $N'=r\times0$ matrix over $T$}
\While{\ref{C:OK-matrix} is not satisfied for $N'$}
	\State{Given $N_1,\ldots,N_{i-1}$, use Algorithm \ref{algo:compute-Ni} to compute $N_i$}
	% \Comment{Call Recursion again}
	\State{Set $N'=N'~|~N_i$}
\EndWhile
\State{Report $P=\gcd(\minors(r, N'))$}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}{\sc Compute Partial Syzygies}{\bf.}
\label{algo:compute-Ni}
\begin{algorithmic}
\State{{\bf input:} a list of matrices of sygygy-generators $N_1,\ldots,N_{i-1}$}
\State{{\bf output:} the syzygy-generators matrix $N_i$}
\For{$0<j<i$}
%	\State{Let $\mt{basis}(T)$ be the basis for $T_{i-j}$ as a row vector}
	\State{Set $N_{ji}=\mt{basis}(T_{i-j})\tensor N_{j}$}
	\State{Set $K_{ji}$ to be the linearization of $N_{ji}$}
\EndFor
\State{Set $K_i=\ker(\Phi^{(i)})$}
\State{Let $K_i'$ be such that $\Span(K_i)=\Span(K_i')\oplus(\sum_j\Span(K_{ji}))$}
\State{Let $N_i$ be such that $\mt{basis}(R_{\mathbf d,i})\cdot K_i'=\mt{basis}(S_{\mathbf d})\cdot N_i$}
\State{Report $N_i$}
\end{algorithmic}
\end{algorithm}



\section{Implementation in Macaulay2}
\label{sec:implementation}

\begin{paragraf*}
We devote this section to implementing Algorithms~\ref{algo:naive} and~\ref{algo:proposed}
in the Macaulay2 system for research in algebraic geometry and commutative algebra,
\citet{M2}.

While not difficult, some care had to be exercised, so we present them here to serve
as a reference for the next section also.
\end{paragraf*}

\begin{code}
\label{code:lemma:push-gens}
We start with Lemma~\ref{lemma:push-gens}.
\label{code:lemma:push-gens}
\begin{verbatim}
Lemma514 = (d,I) -> (
  r := toList(0..(#d-1));
  G := for g in I_* list (
    if all(d-((degree g)_r), Z->Z>=0)
    then basis((d-((degree g)_r))|{0},ring I)**g
    else continue);
  trim image fold(G,matrix {{0_(ring I)}},(a, b)->a|b)
  )
\end{verbatim}
\end{code}

\begin{code}
\label{code:algo:naive}
Using \eqref{code:lemma:push-gens},
Algorithm \ref{algo:naive} becomes straight-forward to implement.
We require~$R$ for encapsulation.
\begin{verbatim}
ComputeNRees = method ()
ComputeNRees (Ideal, List, Ring) := Matrix => (J, d, R) -> (
  x := symbol x;
  I := reesIdeal(J, Variable=>x);
  AI := ring I;
  zm := 0*d;
  g := map(R,AI,first entries super basis(zm|{1},R));
  I = g(I);
  V := Lemma514 (d,I);
  matrix entries ( (gens V) // basis(d|{0}, R) )
  )
\end{verbatim}
\end{code}

\begin{code}
\label{code:algo:compute-Ni}
Algorithm~\ref{algo:compute-Ni} is the one we make most use of in Section~\ref{sec:long-examples}.
Its fourth argument is the list of already computed matrices $N_1,\ldots,N_{i-1}$.
If this list's size is not $i-1$,
then we just compute all linearly independent syzygies of degree~$i$ --- $\basis(I_{\d,i})$.
The ideal $J$ is supplied in the form of a matrix $F=\phi^{(1)}$ (see \ref{par:strands}) over $R$.
\begin{verbatim}
ComputeNi = method ()
ComputeNi (Matrix, ZZ, List, List) := Matrix => (F, i, d, lst) -> (
  R := ring F;
  m := #d;
  d0 := d|{0};
  di := d|{i};
  zm := 0*d;
  fj := flatten entries matrix F;
  xj := flatten entries super basis (zm|{1}, R);
  n := #fj;
  r := numcols super basis(d0, R);
  subs := apply(n,j->xj_j=>fj_j);
  e0 := (degree fj_0);
  G := sub(super basis(di, R), subs) // (super basis(i*e0+d0, R));
  K := matrix entries gens ker G;
  Nii := (super basis(di, R))*K // (super basis(d0, R));
  Nii = sub(matrix entries Nii,R);
  Nji := random(R^r,R^0);
  if #lst==i-1
  then Nji = fold (for j from 1 to #lst list
    (super basis(zm|{i-j}, R)**(lst_(j-1))), random(R^r,R^0), (m1,m2)->m1|m2);
  gens trim image (Nii%Nji)
  )
\end{verbatim}
\end{code}

\begin{code}
\label{code:algo:proposed}
This is the first part of the proposed Algorithm~\ref{algo:proposed}.
We omit the minors speed-up simply because of \itmref{itm:flaws:large-det}{par:flaws}.
Further, after general change of coordinates, two minors ought to suffice,
and we can compute them manually when necessary.
\begin{verbatim}
ComputeNConj = method ()
ComputeNConj (Matrix, ZZ, List) := Matrix => (F, p, d) -> (
  R := ring F;
  q := 0;
  i := 1;
  lst := {};
  r := numcols super basis (d|{0},R);
  N := random(R^r,R^0);
  
  zm := 0*d;
  fj := flatten entries matrix F;
  xj := flatten entries super basis (zm|{1}, R);
  n := #fj;
  subs := apply(n,j->xj_j=>fj_j);
  
  while q<p or not procTestCondN(N, subs) do (
    Ni := ComputeNi(F,i,d,lst);
    q = q + (numcols Ni)*i;
    lst = append(lst, Ni);
    N = N|Ni;
    i = i+1; );
  N
  )
\end{verbatim}
\end{code}



\section{Examples}
\label{sec:long-examples}

\begin{paragraf*}
We now field-test our algorithms and code on several examples of
somewhat higher computational complexity than those in Chapter~\ref{ch:examples}.

The running times can vary a lot from one machine to another,
so the numbers below should not be treated as benchmarks.
We include them only to provide a general idea how the different methods preform
relative to each other.

The machine that we used was a MacBook Pro laptop with
a 2.9 GHz Intel Core i7 processor and 8 GB 1600 MHz DDR3 memory,
running Macaulay2 version 1.8.
\end{paragraf*}

\begin{example}[$\mt{ex601}$]
\label{ex601}
Let $\phi$ be given by 5 generic $(2,1,1)$-forms on
\[
	X=\PP^1_{s_0,s_1}\times\PP^1_{t_0,t_1}\times\PP^1_{u_0,u_1}
\]
The base locus is empty,
so by \eqref{eq:self-intersection} and \eqref{eq:degree-formula},
the degree of the image is $12$.

Consider $\d=(1,1,1)$.
Our method computes the partial matrix $N'$ in a little more than a second.
The standard Gr\"obner basis computation takes more than 6 minutes.
\begin{verbatim}
i1 : loadPackage "ImplicitizationAlgos"

o1 = ImplicitizationAlgos

o1 : Package

i2 : KK=ZZ/32009;

i3 : S=KK[s_0,s_1,t_0,t_1,u_0,u_1,
          Degrees=>{2:{1,0,0},2:{0,1,0},2:{0,0,1}}];

i4 : T=KK[x_0..x_4];

i5 : B=super basis({2,1,1},S);

             1       12
o5 : Matrix S  <--- S

i6 : J=ideal(B*random(S^12,S^5));

o6 : Ideal of S

i7 : R=KK[s_0,s_1,t_0,t_1,u_0,u_1,x_0..x_4,
          Degrees=>{2:{1,0,0,0},2:{0,1,0,0},2:{0,0,1,0},5:{0,0,0,1}}];

i8 : F=sub(gens J,R);

             1       5
o8 : Matrix R  <--- R

i9 : d={1,1,1};

i10 : N1=ComputeNi(F,1,d,{});

              8       4
o10 : Matrix R  <--- R

i11 : time N2=ComputeNi(F,2,d,{N1});
     -- used 0.155756 seconds

              8       4
o11 : Matrix R  <--- R
\end{verbatim}
At this point, the size of $N'=(~N_1~|~N_2~)$ is $12\times12$,
and \eqref{C:OK-matrix} kicks in.
We will see in Chapter~\ref{ch:koszul-bpf} that in this setting $N$ is square,
so $N=N'$ already.

\begin{verbatim}
i12 : time ComputeNi(F,2,d,{});
     -- used 0.155017 seconds

              8       24
o12 : Matrix R  <--- R

i13 : time N3=ComputeNi(F,3,d,{N1,N2});
     -- used 1.94713 seconds

              8
o13 : Matrix R  <--- 0

i14 : time ComputeNi(F,3,d,{});
     -- used 2.00069 seconds

              8       80
o14 : Matrix R  <--- R
\end{verbatim}
While not relevant to our computation, the last 3 commands give us more information
about the syzygies over $(1,1,1)$.
There are 24 linearly independent quadratic syzygies,
4 of which arise from quadratic $R$-generators, so 20 must be coming from linear generators.
Since there are only 4 linear generators, all the quadratic syzygies they give rise to
remain linearly independent to among themselves and the new.

\begin{verbatim}
i15 : N'=sub(N1|N2,T);

              8       8
o15 : Matrix T  <--- T

i16 : time N''=ComputeNConj(F,12,d);
     -- used 0.301989 seconds

              8       8
o16 : Matrix R  <--- R

i17 : N''=sub(N'',T);

              8       8
o17 : Matrix T  <--- T

i18 : image N'==image N''

o18 = true
\end{verbatim}
Finally, we compute the the implicit equation in two ways --- using $N'$ and
using a standard Gr\"obner basis calculation.

\begin{verbatim}
i19 : time P'=ideal det N';
     -- used 6.53631 seconds

o19 : Ideal of T

i20 : time P=ker map(S,T,J_*);
     -- used 367.429 seconds

i21 : P==P'

o21 = true
\end{verbatim}
\end{example}

\begin{example}[$\mt{ex602}$]
\label{ex602}
We compute the implicit equation of five general $(2,2,1)$-forms over $(\PP^1)^3$.
The base locus is empty, so the degree of the equation is $24$.
We find in the form of a determinant of an $18\times18$-matrix of quadratic forms.

\begin{verbatim}
i1 : loadPackage "ImplicitizationAlgos"

o1 = ImplicitizationAlgos

o1 : Package

i2 : KK=ZZ/32009;

i3 : S=KK[s_0,s_1,t_0,t_1,u_0,u_1,
          Degrees=>{2:{1,0,0},2:{0,1,0},2:{0,0,1}}];

i4 : T=KK[x_0..x_4];

i5 : B=super basis({2,2,1},S);

             1       18
o5 : Matrix S  <--- S

i6 : J=ideal(B*random(S^18,S^5));

o6 : Ideal of S

i7 : R=KK[s_0,s_1,t_0,t_1,u_0,u_1,x_0..x_4,
          Degrees=>{2:{1,0,0,0},2:{0,1,0,0},2:{0,0,1,0},5:{0,0,0,1}}];

i8 : F=sub(gens J,R);

             1       5
o8 : Matrix R  <--- R

i9 : d={2,1,1};
\end{verbatim}
We pick $\d=(2,1,1)$.

\begin{verbatim}
i10 : time N1=ComputeNi(F,1,d,{});
     -- used 0.024571 seconds

              12
o10 : Matrix R   <--- 0

i11 : time N2=ComputeNi(F,2,d,{});
     -- used 0.607232 seconds

              12       12
o11 : Matrix R   <--- R

i12 : time N3=ComputeNi(F,3,d,{N2});
     -- used 10.7996 seconds

              12       60
o12 : Matrix R   <--- R

i13 : time N'=ComputeNConj(F,24,d);
     -- used 1.49427 seconds

              12       12
o13 : Matrix R   <--- R
\end{verbatim}
We have that $N_1=0$ and $N_2$ is square.
\end{example}

\begin{example}[$\mt{ex604}$]
\label{ex604}
Consider a map given by four general $(4,4)$-form in the ideal $\la s^3,s^2t,t^2\ra$.
Then the base locus is the point $(0,0,1)$ of degree $5$ and multiplicity $6$.
The degree of the image is $26$.
Our method finds it in less than $15$ minutes,
while it a representation of it in less than $1$ minute.
It highlights the interplay between the algebra and geometry.
The standard method took 6 hours.
\begin{verbatim}
i1 : loadPackage "ImplicitizationAlgos"

o1 = ImplicitizationAlgos

o1 : Package

i2 : KK=ZZ/32009;

i3 : S=KK[s,u,t,v,Degrees=>{2:{1,0},2:{0,1}}];

i4 : T=KK[x_0..x_3];

i5 : Z=ideal(s^3,s^2*t,t^2);

o5 : Ideal of S

i6 : B=super basis({4,4},Z);

             1       20
o6 : Matrix S  <--- S

i7 : J=ideal(B*random(S^20,S^4));

o7 : Ideal of S

i8 : decompose J

o8 = {ideal (t, s), ideal (t, v), ideal (s, u)}

o8 : List

i9 : multiplicity Z

o9 = 6

i10 : R=KK[s,u,t,v,x_0..x_3,Degrees=>{2:{1,0,0},2:{0,1,0},4:{0,0,1}}];

i11 : F=sub(gens J,R);

              1       4
o11 : Matrix R  <--- R

i12 : d={2,2};

i13 : time N1=ComputeNi(F,1,d,{});
     -- used 0.013867 seconds

              9
o13 : Matrix R  <--- 0

i14 : time N2=ComputeNi(F,2,d,{N1});
     -- used 0.161786 seconds

              9
o14 : Matrix R  <--- 0

i15 : d={3,3}

o15 = {3, 3}

o15 : List

i16 : time N1=ComputeNi(F,1,d,{});
     -- used 0.019749 seconds

              16       5
o16 : Matrix R   <--- R

i17 : time N2=ComputeNi(F,2,d,{N1});
     -- used 0.418369 seconds

              16       12
o17 : Matrix R   <--- R

i18 : N=N1|N2;

              16       17
o18 : Matrix R   <--- R

i19 : time rank N
     -- used 0.003566 seconds

o19 = 16

i20 : c1=sort join({0,1,2,3,4}, RandPerm(5,16,11));

i21 : time rank N_c1
     -- used 0.002332 seconds

o21 = 16

i22 : c2=sort join({0,1,2,3,4}, RandPerm(5,16,11));

i23 : c1==c2

o23 = false

i24 : time rank N_c2
     -- used 0.002814 seconds

o24 = 16
\end{verbatim}
\end{example}

\begin{example}[$\mt{ex603}$]
\label{ex603}
We bump-up Example~\ref{ex602} and compute the implicit equation five general
$(2,2,2)$-forms on $(\PP^1)^3$. The base locus again empty, so the degree of $P$ is 48.
\begin{verbatim}
i1 : loadPackage "ImplicitizationAlgos"

o1 = ImplicitizationAlgos

o1 : Package

i2 : KK=ZZ/32009;

i3 : S=KK[s_0,s_1,t_0,t_1,u_0,u_1,Degrees=>{2:{1,0,0},2:{0,1,0},2:{0,0,1}}];

i4 : T=KK[x_0..x_4];

i5 : B=super basis({2,2,2},S);

             1       27
o5 : Matrix S  <--- S

i6 : J=ideal(B*random(S^27,S^5));

o6 : Ideal of S

i7 : R=KK[s_0,s_1,t_0,t_1,u_0,u_1,x_0..x_4,Degrees=>{2:{1,0,0,0},2:{0,1,0,0},2:{0,0,1,0},5:{0,0,0,1}}];

i8 : F=sub(gens J,R);

             1       5
o8 : Matrix R  <--- R

i9 : d={1,1,1};

i10 : N1=ComputeNi(F,1,d,{});

              8
o10 : Matrix R  <--- 0

i11 : N2=ComputeNi(F,2,d,{});

              8
o11 : Matrix R  <--- 0

i12 : N8=ComputeNi(F,8,d,{});

              8
o12 : Matrix R  <--- 0
   -- time 16585.329 seconds
\end{verbatim}
This is going nowhere.
Consider $\d=(2,2,1)$ instead.
\begin{verbatim}
i13 : d = {2,2,1}

o13 = {2, 2, 1}

o13 : List
\end{verbatim}
Fast forward --- $N_1, N_2, N_3$ are all zero.
\begin{verbatim}
i14 : time N4=ComputeNi(F,4,d,{});
     -- used 353.727 seconds

              18       50
o14 : Matrix R   <--- R
\end{verbatim}
We now pick two sets of column-index sets $c_1$ and $c_2$ such that
\eqref{C:matrix} and \eqref{C:minors} are satisfied.
\begin{verbatim}
i15 : time rank N4
     -- used 5.92405 seconds

o15 = 18

i16 : c1=RandPerm(0,49,18);

i17 : M1=N4_c1;

              18       18
o17 : Matrix R   <--- R

i18 : rank M1

o18 = 18

i19 : c2=RandPerm(0,49,18);

i20 : M2=N4_c2;

              18       18
o20 : Matrix R   <--- R

i21 : rank M2

o21 = 18

i22 : sort c1==sort c2

o22 = false

i23 : M1=sub(M1,T);

              18       18
o23 : Matrix T   <--- T

i24 : M2=sub(M2,T);

              18       18
o24 : Matrix T   <--- T
\end{verbatim}
At this point, we have checked \eqref{C:matrix} but still need to check \eqref{C:minors}
since the degree of the minors is $72$,
while the degree of the image is only $48$,
allowing for the intersection of $V(\det(M_1))$ and $V(\det(M_2))$
to be larger than just $Y$.

If that is the case,
\[
	P=\gcd(\det(M_1),\det(M_2))
\]

We test the condition below.
\begin{verbatim}
output here
\end{verbatim}
\end{example}



%% STRIP BEGIN
\end{document}